#!/usr/bin/env python3 """ Reviewer Coordinator ΓÇö branch/label/capability-aware launcher for reviewer_bridge.py  - Loads policy (docs/config/reviewer.policy.yaml) and merges defaults with branch and label rules - Probes GITHUB_TOKEN capabilities (repo permissions), downgrades behavior if needed - Applies safety checks (.codex ignored, protected branches) - Exports REVIEWER_* env vars accordingly and invokes reviewer_bridge.py - Emits artifacts with capabilities and effective policy for traceability  Env (optional overrides) - REVIEWER_STRICT_PERMISSIONS=1           ΓåÆ fail-fast if required capabilities are missing - REVIEWER_REQUIRED_CAPABILITIES=csv      ΓåÆ e.g., "post,label,push" (only in strict mode) - REVIEWER_TARGET_REPOS=org/repoA,org/repoB  ΓåÆ probe cross-repo accessibility """ from __future__ import annotations  import argparse import json import os import re import subprocess import sys import time from pathlib import Path from typing import Any, Dict, List, Optional  import requests from requests.adapters import HTTPAdapter  try:     from urllib3.util.retry import Retry  # type: ignore except Exception:  # pragma: no cover     Retry = None  # Note: avoid PyYAML dependency; YAML parsing is not used here.  GH = "https://api.github.com"   def env_truthy(name: str) -> bool:     v = (os.environ.get(name, "") or "").strip().lower()     return v in ("1", "true", "yes", "y", "on")   _SESSION: Optional[requests.Session] = None   def session() -> requests.Session:     global _SESSION     if _SESSION is None:         s = requests.Session()         retries = int(os.environ.get("REVIEWER_HTTP_RETRIES", "3") or 3)         backoff = float(os.environ.get("REVIEWER_HTTP_BACKOFF_SEC", "0.5") or 0.5)         allowed = frozenset(["GET", "POST"])         if Retry is not None:             retry = Retry(                 total=retries,                 connect=retries,                 read=retries,                 status=retries,                 backoff_factor=backoff,                 status_forcelist=[408, 429, 500, 502, 503, 504, 520, 521, 522, 523, 524, 525, 526, 527],                 allowed_methods=allowed,                 raise_on_status=False,             )             adapter = HTTPAdapter(max_retries=retry)             s.mount("https://", adapter)             s.mount("http://", adapter)         _SESSION = s     return _SESSION   def load_event(path: str) -> Dict[str, Any]:     with open(path, "r", encoding="utf-8") as f:         return json.load(f)   def ctx_from_event(ev: Dict[str, Any]) -> Dict[str, Any]:     repo = ev["repository"]["full_name"]     owner, _, name = repo.partition("/")     pr = 0     branch = ""     labels: List[str] = []     if ev.get("pull_request"):         pr = int(ev["pull_request"]["number"])  # type: ignore         branch = (ev["pull_request"]["head"]["ref"] or "").strip()         labels = [l["name"] for l in ev["pull_request"].get("labels", [])]     elif ev.get("issue") and ev["issue"].get("pull_request"):         pr = int(ev["issue"]["number"])  # type: ignore     return {"owner": owner, "repo": name, "pr": pr, "branch": branch, "labels": labels}   def headers(token: str) -> Dict[str, str]:     return {"Authorization": f"Bearer {token}", "Accept": "application/vnd.github+json"}   def probe_capabilities(token: str, owner: str, repo: str, target_repos: List[str]) -> Dict[str, Any]:     caps: Dict[str, Any] = {"token_type": "unknown", "x_oauth_scopes": "", "targets": []}     s = session()     # rate_limit proves token validity     r = s.get(f"{GH}/rate_limit", headers=headers(token), timeout=15)     r.raise_for_status()     # user endpoint for PAT scopes (Apps may 401)     try:         u = s.get(f"{GH}/user", headers=headers(token), timeout=15)         if u.status_code == 200:             caps["token_type"] = "pat"             caps["x_oauth_scopes"] = u.headers.get("X-OAuth-Scopes", "")     except requests.RequestException:         pass     # repo permissions     r = s.get(f"{GH}/repos/{owner}/{repo}", headers=headers(token), timeout=20)     r.raise_for_status()     js = r.json()     perms = js.get("permissions", {}) or {}     caps["repo"] = f"{owner}/{repo}"     caps["permissions"] = perms     can_read = bool(perms.get("pull"))     can_post = bool(perms.get("triage") or perms.get("push") or perms.get("maintain") or perms.get("admin"))     can_label = can_post     can_push = bool(perms.get("push") or perms.get("maintain") or perms.get("admin"))     caps.update({         "can_read": can_read,         "can_post_review": can_post,         "can_label": can_label,         "can_push": can_push,     })     # token type for App installation (if user didnΓÇÖt return but repo works)     if caps["token_type"] == "unknown" and r.status_code == 200:         caps["token_type"] = "app_installation"     # optional target repos     for tr in target_repos:         tr = tr.strip()         if not tr:             continue         try:             rr = s.get(f"{GH}/repos/{tr}", headers=headers(token), timeout=15)             caps["targets"].append({"repo": tr, "accessible": rr.status_code == 200})         except requests.RequestException:             caps["targets"].append({"repo": tr, "accessible": False})     return caps   def load_policy(path: Path) -> Dict[str, Any]:     if not path.exists():         return {}     text = path.read_text(encoding="utf-8")     if yaml is not None:         try:             return yaml.safe_load(text) or {}         except Exception:             pass     try:         return json.loads(text)     except Exception:         return {}   def match_branch_rule(branch: str, rules: Dict[str, Any]) -> Dict[str, Any]:     # exact match first, then shell-style glob     if branch in rules:         v = rules.get(branch)         return v if isinstance(v, dict) else {}     import fnmatch      for pat, v in rules.items():         try:             if fnmatch.fnmatch(branch, pat) and isinstance(v, dict):                 return v         except Exception:             continue     return {}   def git_ignored(paths: List[Path]) -> bool:     try:         for p in paths:             r = subprocess.run(["git", "check-ignore", "-q", str(p)], capture_output=True)             if r.returncode == 0:                 return True     except Exception:         return False     return False   def write_json(path: Path, obj: Any) -> None:     path.parent.mkdir(parents=True, exist_ok=True)     path.write_text(json.dumps(obj, indent=2), encoding="utf-8")   def main(argv: Optional[List[str]] = None) -> int:     ap = argparse.ArgumentParser(description="Reviewer Coordinator")     ap.add_argument("--event", required=True, help="Path to GitHub event JSON")     ap.add_argument("--policy", default=str(Path("docs/config/reviewer.policy.yaml")), help="Path to policy file (YAML or JSON)")     ns = ap.parse_args(argv)      token = os.environ.get("GITHUB_TOKEN", "").strip()     if not token:         print("[ERR] Missing GITHUB_TOKEN", file=sys.stderr)         return 1      ev = load_event(ns.event)     ctx = ctx_from_event(ev)     if not ctx["pr"]:         print("[WARN] No PR detected in event; exiting.")         return 0      # Capabilities probe     target_repos = [x.strip() for x in (os.environ.get("REVIEWER_TARGET_REPOS", "").split(",")) if x.strip()]     caps = probe_capabilities(token, ctx["owner"], ctx["repo"], target_repos)     if not caps.get("can_read"):         print("[ERR] Token lacks read permission to repo; cannot proceed.", file=sys.stderr)         write_json(Path("artifacts/reviewer/capabilities.json"), caps)         return 2      # Policy resolve     pol = load_policy(Path(ns.policy))     defaults = (pol.get("defaults") or {}) if isinstance(pol, dict) else {}     branch_rules = (pol.get("branches") or {}) if isinstance(pol, dict) else {}     label_rules = (pol.get("labels") or {}) if isinstance(pol, dict) else {}     source_rules = (pol.get("sources") or {}) if isinstance(pol, dict) else {}      # Start with defaults     eff: Dict[str, Any] = {}     eff.update(defaults)      # Source: fork     is_fork = False     try:         is_fork = bool(ev.get("pull_request", {}).get("head", {}).get("repo", {}).get("fork", False))     except Exception:         is_fork = False     if is_fork and isinstance(source_rules.get("fork"), dict):         eff.update(source_rules["fork"])  # type: ignore      # Branch rule     if isinstance(branch_rules, dict):         br = match_branch_rule(ctx["branch"], branch_rules)         eff.update(br)      # Labels (API fetch to ensure current)     try:         r = session().get(f"{GH}/repos/{ctx['owner']}/{ctx['repo']}/issues/{ctx['pr']}", headers=headers(token), timeout=20)         r.raise_for_status()         issue = r.json()         labels = [l["name"] for l in issue.get("labels", [])]     except Exception:         labels = ctx.get("labels") or []     # Apply label overrides (last-wins)     for lb in labels:         if lb in label_rules and isinstance(label_rules[lb], dict):             eff.update(label_rules[lb])  # type: ignore      # Capabilities downgrade     if not caps.get("can_post_review"):         eff["no_post"] = True         eff["no_labels"] = True     if not caps.get("can_label"):         eff["no_labels"] = True     if not caps.get("can_push"):         eff["comment_only"] = True      # Safety: .codex ignored ΓåÆ force comment_only     if git_ignored([Path(".codex"), Path(".codex/reviews")]):         eff["comment_only"] = True      # Strict mode: enforce required capabilities     strict = env_truthy("REVIEWER_STRICT_PERMISSIONS")     req_env = (os.environ.get("REVIEWER_REQUIRED_CAPABILITIES", "") or "").strip()     required: List[str] = []     if req_env:         required = [x.strip().lower() for x in req_env.split(",") if x.strip()]     else:         # Derive from effective policy         if not bool(eff.get("no_post")):             required.append("post")         if not bool(eff.get("no_labels")):             required.append("label")         if not bool(eff.get("comment_only")) and not bool(eff.get("dry_run")):             required.append("push")     if strict and required:         missing: List[str] = []         for cap in required:             if cap == "post" and not caps.get("can_post_review"):                 missing.append("post")             elif cap == "label" and not caps.get("can_label"):                 missing.append("label")             elif cap == "push" and not caps.get("can_push"):                 missing.append("push")         if missing:             print(                 "[ERR] Token lacks required capabilities for this run: " + ", ".join(sorted(set(missing))) +                 "; requested=" + ", ".join(sorted(set(required))) +                 "; repo perms=" + json.dumps(caps.get("permissions", {})),                 file=sys.stderr,             )             write_json(Path("artifacts/reviewer/capabilities.json"), caps)             return 3      # Map to env     def set_flag(name: str, v: Any) -> None:         if isinstance(v, bool):             os.environ[name] = "1" if v else "0"         elif v is not None:             os.environ[name] = str(v)      set_flag("REVIEWER_DETERMINISTIC", eff.get("deterministic"))     set_flag("REVIEWER_FREEZE_INPUTS", eff.get("freeze_inputs"))     set_flag("REVIEWER_FREEZE_REVIEW", eff.get("freeze_review"))     set_flag("REVIEWER_NO_POST", eff.get("no_post"))     set_flag("REVIEWER_NO_LABELS", eff.get("no_labels"))     set_flag("REVIEWER_COMMENT_ONLY", eff.get("comment_only"))     set_flag("REVIEWER_DRY_RUN", eff.get("dry_run"))     # LLM params     if "temperature" in eff:         set_flag("REVIEWER_TEMPERATURE", eff.get("temperature"))     if "top_p" in eff:         set_flag("REVIEWER_TOP_P", eff.get("top_p"))     if "seed" in eff:         set_flag("REVIEWER_SEED", eff.get("seed"))     # HTTP     http = eff.get("http") or {}     if isinstance(http, dict):         if "retries" in http:             set_flag("REVIEWER_HTTP_RETRIES", http.get("retries"))         if "backoff_sec" in http:             set_flag("REVIEWER_HTTP_BACKOFF_SEC", http.get("backoff_sec"))         if "jitter_sec" in http:             set_flag("REVIEWER_HTTP_JITTER_SEC", http.get("jitter_sec"))      # Default output path when not posting     no_post = env_truthy("REVIEWER_NO_POST") or env_truthy("REVIEWER_DRY_RUN")     comment_only = env_truthy("REVIEWER_COMMENT_ONLY")     if (no_post or comment_only) and not (os.environ.get("REVIEWER_OUTPUT_PATH") or "").strip():         outp = Path(f"artifacts/reviewer/pr{ctx['pr']}.md")         outp.parent.mkdir(parents=True, exist_ok=True)         os.environ["REVIEWER_OUTPUT_PATH"] = str(outp)      # Artifacts: capabilities and effective     write_json(Path("artifacts/reviewer/capabilities.json"), caps)     write_json(Path("artifacts/reviewer/effective-policy.json"), {         "ctx": ctx,         "policy": pol,         "effective": eff,         "env": {k: v for k, v in os.environ.items() if k.startswith("REVIEWER_")},     })      # Exec reviewer_bridge.py     cmd = [sys.executable, "scripts/reviewer_bridge.py", "--event", ns.event]     rc = subprocess.call(cmd)     return int(rc)   if __name__ == "__main__":  # pragma: no cover     raise SystemExit(main()) 
