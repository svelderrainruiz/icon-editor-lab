.PHONY: agents-digest IMAGE_NAME ?= ghcr.io/labview-community-ci-cd/x-cli TAG ?= dev-$(shell git rev-parse --short HEAD) CUR_BRANCH ?= $(shell git rev-parse --abbrev-ref HEAD 2>/dev/null)  agents-digest: 	./scripts/gen-agent-digest.sh AGENTS.md  .PHONY: test-ci-guard test-ci-guard: 	node tests/__ci__/codex_guard_verify.test.js  .PHONY: bootstrap bootstrap: 	./scripts/bootstrap.sh  .PHONY: hooks hooks: 	./scripts/hooks-install.sh  .PHONY: hooks-win hooks-win: 	pwsh -NoLogo -NoProfile -File scripts/setup-git-hooks.ps1  .PHONY: test-changed test-changed: 	./scripts/qa.sh --changed-only  .PHONY: pack-cli pack-cli: 	./scripts/pack-cli.sh  .PHONY: docker docker: pack-cli 	./scripts/build-container.sh x-cli:dev  .PHONY: docker-source docker-source: 	docker build --target source-image -t x-cli:dev .  .PHONY: docker-smoke docker-smoke: 	docker run --rm x-cli:dev --help | head -n 1 	docker run --rm x-cli:dev --version  .PHONY: docker-login-ghcr docker-login-ghcr: 	@if [ -z "$$GHCR_USER" ] || [ -z "$$GHCR_TOKEN" ]; then \ 		echo "Set GHCR_USER and GHCR_TOKEN to login to ghcr.io" >&2; exit 1; \ 	fi 	echo "$$GHCR_TOKEN" | docker login ghcr.io -u "$$GHCR_USER" --password-stdin  .PHONY: guard-main guard-main: 	@if [ "$(CUR_BRANCH)" != "main" ] && [ "$$ALLOW_NON_MAIN" != "1" ]; then \ 		echo "Refusing to push from branch '$(CUR_BRANCH)'. Set ALLOW_NON_MAIN=1 to override." >&2; \ 		exit 1; \ 	fi  .PHONY: release-container release-container: guard-main docker 	@if [ -z "$(IMAGE_NAME)" ]; then echo "IMAGE_NAME is required" >&2; exit 1; fi 	@echo "Tagging and pushing $(IMAGE_NAME):$(TAG)" 	docker tag x-cli:dev $(IMAGE_NAME):$(TAG) 	docker push $(IMAGE_NAME):$(TAG) 	@if [ "$$PUSH_LATEST" = "1" ]; then \ 		echo "Also pushing latest"; \ 		docker tag x-cli:dev $(IMAGE_NAME):latest; \ 		docker push $(IMAGE_NAME):latest; \ 	fi  .PHONY: release-dev release-dev: 	$(MAKE) release-container IMAGE_NAME=$(IMAGE_NAME) TAG=dev-$(shell git rev-parse --short HEAD)  .PHONY: release-latest release-latest: 	@# Auto-derive TAG from latest annotated/semver tag when not provided 	@if [ -z "$(TAG)" ]; then \ 	  TAG=$$(git describe --tags --abbrev=0 2>/dev/null || git tag --sort=-v:refname | head -n 1); \ 	  if [ -z "$$TAG" ]; then \ 	    echo "No git tags found. Provide TAG (e.g., TAG=v1.2.3) or create a tag first." >&2; exit 1; \ 	  fi; \ 	  echo "Derived TAG=$$TAG"; \ 	fi; \ 	SEMVER_RE='^v([0-9]+)\.([0-9]+)\.([0-9]+)(-[0-9A-Za-z.-]+)?(\+[0-9A-Za-z.-]+)?$$'; \ 	if ! echo "$$TAG" | grep -E -q "$$SEMVER_RE"; then \ 	  echo "TAG must be SemVer: vMAJOR.MINOR.PATCH[ -PRERELEASE][ +BUILD] (e.g., v1.2.3, v1.2.3-rc.1)" >&2; exit 1; \ 	fi; \ 	$(MAKE) release-container IMAGE_NAME=$(IMAGE_NAME) TAG=$$TAG PUSH_LATEST=1  .PHONY: tag-and-release tag-and-release: guard-main 	@if [ -z "$(VERSION)" ]; then echo "Set VERSION (e.g., VERSION=1.2.3 or VERSION=v1.2.3)" >&2; exit 1; fi 	@TAG="$(VERSION)"; if echo "$$TAG" | grep -vq '^v'; then TAG="v$$TAG"; fi; \ 	SEMVER_RE='^v([0-9]+)\.([0-9]+)\.([0-9]+)(-[0-9A-Za-z.-]+)?(\+[0-9A-Za-z.-]+)?$$'; \ 	if ! echo "$$TAG" | grep -E -q "$$SEMVER_RE"; then \ 	  echo "VERSION must be SemVer (vMAJOR.MINOR.PATCH optionally with pre-release/build)." >&2; exit 1; \ 	fi; \ 	if git rev-parse "$$TAG" >/dev/null 2>&1; then \ 	  echo "Tag $$TAG already exists" >&2; exit 1; \ 	fi; \ 	if [ -n "$$(/usr/bin/env git status --porcelain)" ]; then \ 	  echo "Working tree not clean. Commit or stash changes before tagging." >&2; exit 1; \ 	fi; \ 	echo "Creating and pushing tag $$TAG"; \ 	git tag -a "$$TAG" -m "Release $$TAG"; \ 	git push origin "$$TAG"; \ 	$(MAKE) release-latest IMAGE_NAME=$(IMAGE_NAME) TAG="$$TAG"  .PHONY: agent-bootstrap agent-bootstrap: 	@./scripts/agent_bootstrap_gitflow.sh  # --- First run (onboarding) --- .PHONY: first-run first-run: 	@set -e; \ 	if command -v pwsh >/dev/null 2>&1; then \ 	  pwsh -NoLogo -NoProfile -File scripts/first-run.ps1; \ 	elif command -v pwsh.exe >/dev/null 2>&1; then \ 	  pwsh.exe -NoLogo -NoProfile -File scripts/first-run.ps1; \ 	elif command -v bash >/dev/null 2>&1; then \ 	  bash scripts/first-run.sh; \ 	else \ 	  echo "Install PowerShell 7 or Bash to run first-run" >&2; exit 1; \ 	fi  # --- Diagnostics Validation --- .PHONY: validate-stage3-diag validate-stage3-diag-strict validate-stage3-diag-py validate-stage2-diag  validate-stage3-diag: 	pwsh -NoLogo -NoProfile -File scripts/validate-stage3-diagnostics.ps1  validate-stage3-diag-strict: 	pwsh -NoLogo -NoProfile -File scripts/validate-stage3-diagnostics.ps1 -Strict  validate-stage3-diag-py: 	python scripts/validate_stage3_diagnostics.py --strict  validate-stage2-diag: 	@set -e; \ 	python - <<'PY' import json,sys p='telemetry/stage2-diagnostics.json' try:     with open(p,'r',encoding='utf-8') as f:         d=json.load(f) except Exception as e:     print(f"::error::invalid JSON in {p}: {e}")     sys.exit(1) for k in ('summary_path','manifest_path','summary_bytes','manifest_bytes','dist_count'):     if k not in d:         print(f"::error::missing key: {k}")         sys.exit(1) print('OK: stage2 diagnostics valid') PY  .PHONY: conveyor conveyor-utc conveyor-json monitor-run orchestrate-run  conveyor: 	pwsh -NoLogo -NoProfile -File scripts/dev/conveyor-summary.ps1  conveyor-utc: 	pwsh -NoLogo -NoProfile -File scripts/dev/conveyor-summary.ps1 -TimeFmt utc  conveyor-json: 	pwsh -NoLogo -NoProfile -File scripts/dev/conveyor-summary.ps1 -JsonOut artifacts/conveyor-summary.json  monitor-run: 	pwsh -NoLogo -NoProfile -File scripts/dev/monitor-delegate.ps1 $(ARGS)  orchestrate-run: 	pwsh -NoLogo -NoProfile -File scripts/dev/orchestrate-multi-repo.ps1 $(ARGS)
