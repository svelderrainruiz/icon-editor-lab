name: ci-windows-signed

on:
  pull_request:
  push:
    branches: [develop]
    tags: ['v*']

permissions:
  contents: read

env:
  TSA_URL: https://timestamp.digicert.com
  SIGN_ROOT: out

defaults:
  run:
    shell: pwsh

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build
        run: |
          if (-not (Test-Path '${{ env.SIGN_ROOT }}')) {
            New-Item -ItemType Directory -Path '${{ env.SIGN_ROOT }}' | Out-Null
          }
          $samplePs1 = Join-Path '${{ env.SIGN_ROOT }}' 'Sample-Signed.ps1'
          "Write-Output 'Sample payload for signing test.'" | Set-Content -Path $samplePs1 -Encoding UTF8
          $sampleExe = Join-Path '${{ env.SIGN_ROOT }}' 'sample.exe'
          [IO.File]::WriteAllBytes($sampleExe, [byte[]](1..16))
          Write-Host 'Generated placeholder artifacts under ${{ env.SIGN_ROOT }}. Replace this block with actual build steps.'

      - name: Self-sign outputs for PRs (ephemeral cert)
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          $root = (Test-Path '${{ env.SIGN_ROOT }}') ? '${{ env.SIGN_ROOT }}' : '.'
          $cert = New-SelfSignedCertificate -Subject 'CN=CI Ephemeral Code Signing' -Type CodeSigningCert -CertStoreLocation Cert:\CurrentUser\My -NotAfter (Get-Date).AddDays(14)
          $thumb = $cert.Thumbprint
          $scripts = Get-ChildItem $root -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            Set-AuthenticodeSignature -FilePath $s.FullName -Certificate $cert -HashAlgorithm SHA256 | Out-Null
          }
          $signtool = (Get-Command signtool.exe).Source
          $tsa = '${{ env.TSA_URL }}'
          $pe = Get-ChildItem $root -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) {
            & $signtool sign /fd SHA256 /sm /sha1 $thumb /tr $tsa /td SHA256 $f.FullName
          }

      - name: Verify PR script signatures (presence check)
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          $root = (Test-Path '${{ env.SIGN_ROOT }}') ? '${{ env.SIGN_ROOT }}' : '.'
          $unsigned = Get-ChildItem $root -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue | Where-Object { (Get-AuthenticodeSignature $_).Status -eq 'NotSigned' }
          if ($unsigned.Count -gt 0) {
            'Unsigned scripts detected:' | Write-Host
            $unsigned | Select-Object -ExpandProperty FullName | Write-Host
            throw 'Some scripts were not signed in the PR job.'
          } else {
            'All scripts have a signature (trust may be untrusted, which is expected on PRs).' | Write-Host
          }

      - name: Cleanup ephemeral PR cert
        if: ${{ always() && github.event_name == 'pull_request' }}
        run: |
          Get-ChildItem Cert:\CurrentUser\My | Where-Object { $_.Subject -eq 'CN=CI Ephemeral Code Signing' } | ForEach-Object { certutil -user -delstore My $_.Thumbprint | Out-Null }

      - name: Upload unsigned artifacts for trusted runs
        if: ${{ github.event_name == 'push' }}
        uses: actions/upload-artifact@v4
        with:
          name: unsigned
          path: |
            ${{ env.SIGN_ROOT }}/**/*.exe
            ${{ env.SIGN_ROOT }}/**/*.dll
            ${{ env.SIGN_ROOT }}/**/*.msi
            ${{ env.SIGN_ROOT }}/**/*.ps1
            ${{ env.SIGN_ROOT }}/**/*.psm1
          if-no-files-found: error

  codesign-dev:
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/heads/develop') }}
    needs: build
    runs-on: windows-latest
    timeout-minutes: 30
    environment: codesign-dev
    env:
      EXPECTED_THUMBPRINT: ${{ vars.PROD_CERT_THUMBPRINT }}
      TSA_URL: ${{ vars.CODE_SIGNING_TSA_URL != '' && vars.CODE_SIGNING_TSA_URL || 'https://timestamp.digicert.com' }}
    steps:
      - name: Download unsigned artifacts
        uses: actions/download-artifact@v4
        with:
          name: unsigned
          path: unsigned

      - name: Require code-signing secrets
        run: |
          if ([string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_B64 }}') -or [string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}')) {
            throw 'Missing WIN_CODESIGN_PFX_B64 or WIN_CODESIGN_PFX_PASSWORD in environment codesign-dev.'
          }

      - name: Decode PFX (temp file)
        run: |
          [IO.File]::WriteAllBytes("$env:RUNNER_TEMP\\codesign.pfx", [Convert]::FromBase64String('${{ secrets.WIN_CODESIGN_PFX_B64 }}'))

      - name: Sign binaries (signtool)
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE signing.'; return }
          $signtool = $signtoolCmd.Source
          $tsa = '${{ env.TSA_URL }}'
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) {
            & $signtool sign /fd SHA256 /f "$env:RUNNER_TEMP\\codesign.pfx" /p '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' /tr $tsa /td SHA256 $f.FullName
          }

      - name: Sign scripts (Authenticode) — fork-safe (no timestamp, timeout, progress)
        if: ${{ github.repository != 'LabVIEW-Community-CI-CD/icon-editor-lab' }}
        shell: pwsh
        env:
          TS_TIMEOUT_SEC: 20
          MAX_SIGN_FILES: 500
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest
          # Create and trust ephemeral cert
          $cert = New-SelfSignedCertificate -Subject 'CN=CI Ephemeral Code Signing' -Type CodeSigningCert -CertStoreLocation Cert:\CurrentUser\My -NotAfter (Get-Date).AddDays(14)
          $tmp = Join-Path $env:RUNNER_TEMP 'ci-ephemeral.cer'
          Export-Certificate -Cert $cert -FilePath $tmp | Out-Null
          Import-Certificate -FilePath $tmp -CertStoreLocation 'Cert:\CurrentUser\TrustedPublisher' | Out-Null
          Import-Certificate -FilePath $tmp -CertStoreLocation 'Cert:\CurrentUser\Root' | Out-Null

          $thumb = $cert.Thumbprint
          $files = Get-ChildItem unsigned -Recurse -File -Include *.ps1,*.psm1 -ErrorAction SilentlyContinue | Select-Object -First ([int]$env:MAX_SIGN_FILES)
          if (-not $files) { Write-Host 'No scripts to sign.'; exit 0 }

          function Invoke-SignWithTimeout {
            param([string]$Path,[string]$Thumb,[int]$TimeoutSec)
            $sw = [System.Diagnostics.Stopwatch]::StartNew()
            $sb = { param($p,$t) $c = Get-ChildItem "Cert:\CurrentUser\My\$t"; Set-AuthenticodeSignature -FilePath $p -Certificate $c -HashAlgorithm SHA256 | Out-Null }
            $job = Start-Job -ScriptBlock $sb -ArgumentList $Path,$Thumb
            if (-not (Wait-Job $job -Timeout $TimeoutSec)) { try { Stop-Job $job -Force } catch {} ; $sw.Stop(); return @{ status='timeout'; ms=$sw.ElapsedMilliseconds } }
            try { Receive-Job $job -ErrorAction Stop | Out-Null; $sw.Stop(); return @{ status='ok'; ms=$sw.ElapsedMilliseconds } } catch { $sw.Stop(); return @{ status='error'; error=$_.Exception.Message; ms=$sw.ElapsedMilliseconds } }
          }

          $i=0; $fail=0; $timeout=[int]$env:TS_TIMEOUT_SEC
          foreach ($f in $files) {
            $i++
            Write-Host ("[{0}/{1}] Signing {2}" -f $i,$files.Count,$f.FullName)
            $res = Invoke-SignWithTimeout -Path $f.FullName -Thumb $thumb -TimeoutSec $timeout
            switch ($res.status) { 'ok' { Write-Host ("  ✔ ok ({0} ms)" -f $res.ms) } 'timeout' { Write-Warning ("  ⏱ timeout after {0} ms" -f $res.ms); $fail++ } 'error' { Write-Warning ("  ⚠ error: {0}" -f $res.error); $fail++ } }
          }
          if ($fail -gt 0) { throw "$fail script(s) failed to sign (fork path)." }

      - name: Sign scripts (Authenticode) — upstream (timestamp + timeout + fallback)
        if: ${{ github.repository == 'LabVIEW-Community-CI-CD/icon-editor-lab' }}
        shell: pwsh
        env:
          TSA_URL: ${{ env.TSA_URL }}
          TS_TIMEOUT_SEC: 25
          MAX_SIGN_FILES: 2000
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest
          # Load cert from PFX
          try {
            $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::UserKeySet -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet
            $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new("$env:RUNNER_TEMP\codesign.pfx", '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}', $flags)
          } catch {
            Write-Warning "Direct PFX load failed; attempting store import fallback. Error: $($_.Exception.Message)"
            $pwd = ConvertTo-SecureString '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' -AsPlainText -Force
            $cert = Import-PfxCertificate -FilePath "$env:RUNNER_TEMP\codesign.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password $pwd
          }
          $thumb = $cert.Thumbprint
          $tsa   = if ([string]::IsNullOrWhiteSpace($env:TSA_URL)) { 'https://timestamp.digicert.com' } else { $env:TSA_URL }
          $files = Get-ChildItem unsigned -Recurse -File -Include *.ps1,*.psm1 -ErrorAction SilentlyContinue | Select-Object -First ([int]$env:MAX_SIGN_FILES)
          if (-not $files) { Write-Host 'No scripts to sign.'; exit 0 }

          function Invoke-SignWithTimeout {
            param([string]$Path,[string]$Thumb,[int]$TimeoutSec,[string]$TimestampUrl,[bool]$UseTs)
            $sw = [System.Diagnostics.Stopwatch]::StartNew()
            $sb = { param($p,$t,$tsa,$useTS) $c = Get-ChildItem "Cert:\CurrentUser\My\$t"; if ($useTS -and $tsa) { Set-AuthenticodeSignature -FilePath $p -Certificate $c -TimestampServer $tsa -HashAlgorithm SHA256 | Out-Null } else { Set-AuthenticodeSignature -FilePath $p -Certificate $c -HashAlgorithm SHA256 | Out-Null } }
            $job = Start-Job -ScriptBlock $sb -ArgumentList $Path,$Thumb,$TimestampUrl,$UseTs
            if (-not (Wait-Job $job -Timeout $TimeoutSec)) { try { Stop-Job $job -Force } catch {} ; $sw.Stop(); return @{ status='timeout'; ms=$sw.ElapsedMilliseconds } }
            try { Receive-Job $job -ErrorAction Stop | Out-Null; $sw.Stop(); return @{ status='ok'; ms=$sw.ElapsedMilliseconds } } catch { $sw.Stop(); return @{ status='error'; error=$_.Exception.Message; ms=$sw.ElapsedMilliseconds } }
          }

          $i=0; $fail=0; $timeout=[int]$env:TS_TIMEOUT_SEC
          foreach ($f in $files) {
            $i++
            Write-Host ("[{0}/{1}] Signing {2} with TSA {3}" -f $i,$files.Count,$f.FullName,$tsa)
            $res = Invoke-SignWithTimeout -Path $f.FullName -Thumb $thumb -TimeoutSec $timeout -TimestampUrl $tsa -UseTs:$true
            switch ($res.status) {
              'ok'      { Write-Host ("  ✔ ok ({0} ms)" -f $res.ms) }
              'timeout' { Write-Warning ("  ⏱ TSA timeout after {0} ms; retrying WITHOUT timestamp" -f $res.ms); $res2 = Invoke-SignWithTimeout -Path $f.FullName -Thumb $thumb -TimeoutSec $timeout -UseTs:$false; if ($res2.status -eq 'ok') { Write-Host ("  ✔ ok (no timestamp) ({0} ms)" -f $res2.ms) } else { $fail++ ; Write-Error "  ✖ failed (no timestamp): $($res2.error)" } }
              'error'   { Write-Warning ("  ⚠ TSA error: {0}; retrying WITHOUT timestamp" -f $res.error); $res2 = Invoke-SignWithTimeout -Path $f.FullName -Thumb $thumb -TimeoutSec $timeout -UseTs:$false; if ($res2.status -eq 'ok') { Write-Host ("  ✔ ok (no timestamp) ({0} ms)" -f $res2.ms) } else { $fail++ ; Write-Error "  ✖ failed (no timestamp): $($res2.error)" } }
            }
          }
          if ($fail -gt 0) { throw "$fail script(s) failed to sign." }

      - name: Verify PE signatures
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE verify.'; return }
          $signtool = $signtoolCmd.Source
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) { & $signtool verify /pa $f.FullName }

      - name: Verify script signatures
        run: |
          $expected = '${{ env.EXPECTED_THUMBPRINT }}'
          $invalid = @()
          $scripts = Get-ChildItem unsigned -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            $sig = Get-AuthenticodeSignature $s.FullName
            if ($sig.Status -ne 'Valid') { $invalid += $s.FullName; continue }
            if ($expected -and $sig.SignerCertificate.Thumbprint -ne $expected) {
              throw "Unexpected signer for $($s.Name): $($sig.SignerCertificate.Thumbprint), expected $expected"
            }
          }
          if ($invalid.Count -gt 0) {
            'Scripts with invalid signatures:' | Write-Host
            $invalid | ForEach-Object { $_ | Write-Host }
            throw 'Invalid script signatures'
          }

      - name: Upload signed artifacts (develop)
        uses: actions/upload-artifact@v4
        with:
          name: signed-develop
          path: unsigned

      - name: Cleanup PFX
        if: always()
        run: Remove-Item "$env:RUNNER_TEMP\\codesign.pfx" -Force -ErrorAction SilentlyContinue

  codesign-prod:
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    needs: build
    runs-on: windows-latest
    timeout-minutes: 30
    environment: codesign-prod
    env:
      EXPECTED_THUMBPRINT: ${{ vars.PROD_CERT_THUMBPRINT }}
      TSA_URL: ${{ vars.CODE_SIGNING_TSA_URL != '' && vars.CODE_SIGNING_TSA_URL || 'https://timestamp.digicert.com' }}
    steps:
      - name: Download unsigned artifacts
        uses: actions/download-artifact@v4
        with:
          name: unsigned
          path: unsigned

      - name: Require code-signing secrets
        run: |
          if ([string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_B64 }}') -or [string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}')) {
            throw 'Missing WIN_CODESIGN_PFX_B64 or WIN_CODESIGN_PFX_PASSWORD in environment codesign-prod.'
          }

      - name: Decode PFX (temp file)
        run: |
          [IO.File]::WriteAllBytes("$env:RUNNER_TEMP\\codesign.pfx", [Convert]::FromBase64String('${{ secrets.WIN_CODESIGN_PFX_B64 }}'))

      - name: Sign binaries (signtool)
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE signing.'; return }
          $signtool = $signtoolCmd.Source
          $tsa = '${{ env.TSA_URL }}'
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) {
            & $signtool sign /fd SHA256 /f "$env:RUNNER_TEMP\\codesign.pfx" /p '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' /tr $tsa /td SHA256 $f.FullName
          }

      - name: Sign scripts (Authenticode) — prod (timestamp + timeout + fallback)
        env:
          TSA_URL: ${{ env.TSA_URL }}
          TS_TIMEOUT_SEC: 25
          MAX_SIGN_FILES: 2000
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest
          # Load cert from PFX (trusted path only; secrets are required earlier)
          try {
            $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::UserKeySet -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet
            $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new("$env:RUNNER_TEMP\codesign.pfx", '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}', $flags)
          } catch {
            Write-Warning "Direct PFX load failed; attempting store import fallback. Error: $($_.Exception.Message)"
            $pwd = ConvertTo-SecureString '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' -AsPlainText -Force
            $cert = Import-PfxCertificate -FilePath "$env:RUNNER_TEMP\codesign.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password $pwd
          }
          $thumb = $cert.Thumbprint
          $tsa   = if ([string]::IsNullOrWhiteSpace($env:TSA_URL)) { 'https://timestamp.digicert.com' } else { $env:TSA_URL }
          $files = Get-ChildItem unsigned -Recurse -File -Include *.ps1,*.psm1 -ErrorAction SilentlyContinue | Select-Object -First ([int]$env:MAX_SIGN_FILES)
          if (-not $files) { Write-Host 'No scripts to sign.'; exit 0 }

          function Invoke-SignWithTimeout {
            param([string]$Path,[string]$Thumb,[int]$TimeoutSec,[string]$TimestampUrl,[bool]$UseTs)
            $sw = [System.Diagnostics.Stopwatch]::StartNew()
            $sb = { param($p,$t,$tsa,$useTS) $c = Get-ChildItem "Cert:\CurrentUser\My\$t"; if ($useTS -and $tsa) { Set-AuthenticodeSignature -FilePath $p -Certificate $c -TimestampServer $tsa -HashAlgorithm SHA256 | Out-Null } else { Set-AuthenticodeSignature -FilePath $p -Certificate $c -HashAlgorithm SHA256 | Out-Null } }
            $job = Start-Job -ScriptBlock $sb -ArgumentList $Path,$Thumb,$TimestampUrl,$UseTs
            if (-not (Wait-Job $job -Timeout $TimeoutSec)) { try { Stop-Job $job -Force } catch {} ; $sw.Stop(); return @{ status='timeout'; ms=$sw.ElapsedMilliseconds } }
            try { Receive-Job $job -ErrorAction Stop | Out-Null; $sw.Stop(); return @{ status='ok'; ms=$sw.ElapsedMilliseconds } } catch { $sw.Stop(); return @{ status='error'; error=$_.Exception.Message; ms=$sw.ElapsedMilliseconds } }
          }

          $i=0; $fail=0; $timeout=[int]$env:TS_TIMEOUT_SEC
          foreach ($s in $files) {
            $i++
            Write-Host ("[{0}/{1}] Signing {2} with TSA {3}" -f $i,$files.Count,$s.FullName,$tsa)
            $res = Invoke-SignWithTimeout -Path $s.FullName -Thumb $thumb -TimeoutSec $timeout -TimestampUrl $tsa -UseTs:$true
            switch ($res.status) {
              'ok'      { Write-Host ("  ✔ ok ({0} ms)" -f $res.ms) }
              'timeout' { Write-Warning ("  ⏱ TSA timeout after {0} ms; retrying WITHOUT timestamp" -f $res.ms); $res2 = Invoke-SignWithTimeout -Path $s.FullName -Thumb $thumb -TimeoutSec $timeout -UseTs:$false; if ($res2.status -eq 'ok') { Write-Host ("  ✔ ok (no timestamp) ({0} ms)" -f $res2.ms) } else { $fail++ ; Write-Error "  ✖ failed (no timestamp): $($res2.error)" } }
              'error'   { Write-Warning ("  ⚠ TSA error: {0}; retrying WITHOUT timestamp" -f $res.error); $res2 = Invoke-SignWithTimeout -Path $s.FullName -Thumb $thumb -TimeoutSec $timeout -UseTs:$false; if ($res2.status -eq 'ok') { Write-Host ("  ✔ ok (no timestamp) ({0} ms)" -f $res2.ms) } else { $fail++ ; Write-Error "  ✖ failed (no timestamp): $($res2.error)" } }
            }
          }
          if ($fail -gt 0) { throw "$fail script(s) failed to sign." }

      - name: Verify PE signatures
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE verify.'; return }
          $signtool = $signtoolCmd.Source
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) { & $signtool verify /pa $f.FullName }

      - name: Verify script signatures
        run: |
          $expected = '${{ env.EXPECTED_THUMBPRINT }}'
          $invalid = @()
          $scripts = Get-ChildItem unsigned -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            $sig = Get-AuthenticodeSignature $s.FullName
            if ($sig.Status -ne 'Valid') { $invalid += $s.FullName; continue }
            if ($expected -and $sig.SignerCertificate.Thumbprint -ne $expected) {
              throw "Unexpected signer for $($s.Name): $($sig.SignerCertificate.Thumbprint), expected $expected"
            }
          }
          if ($invalid.Count -gt 0) {
            'Scripts with invalid signatures:' | Write-Host
            $invalid | ForEach-Object { $_ | Write-Host }
            throw 'Invalid script signatures'
          }

      - name: Upload signed artifacts (prod)
        uses: actions/upload-artifact@v4
        with:
          name: signed-prod
          path: unsigned

      - name: Cleanup PFX
        if: always()
        run: Remove-Item "$env:RUNNER_TEMP\\codesign.pfx" -Force -ErrorAction SilentlyContinue
