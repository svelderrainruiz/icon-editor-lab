name: ci-windows-signed

on:
  pull_request:
  push:
    branches: [develop]
    tags: ['v*']

permissions:
  contents: read

env:
  TSA_URL: http://timestamp.digicert.com
  SIGN_ROOT: out

defaults:
  run:
    shell: pwsh

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build
        run: |
          if (-not (Test-Path '${{ env.SIGN_ROOT }}')) {
            New-Item -ItemType Directory -Path '${{ env.SIGN_ROOT }}' | Out-Null
          }
          $samplePs1 = Join-Path '${{ env.SIGN_ROOT }}' 'Sample-Signed.ps1'
          "Write-Output 'Sample payload for signing test.'" | Set-Content -Path $samplePs1 -Encoding UTF8
          $sampleExe = Join-Path '${{ env.SIGN_ROOT }}' 'sample.exe'
          [IO.File]::WriteAllBytes($sampleExe, [byte[]](1..16))
          Write-Host 'Generated placeholder artifacts under ${{ env.SIGN_ROOT }}. Replace this block with actual build steps.'

      - name: Self-sign outputs for PRs (ephemeral cert)
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          $root = (Test-Path '${{ env.SIGN_ROOT }}') ? '${{ env.SIGN_ROOT }}' : '.'
          $cert = New-SelfSignedCertificate -Subject 'CN=CI Ephemeral Code Signing' -Type CodeSigningCert -CertStoreLocation Cert:\CurrentUser\My -NotAfter (Get-Date).AddDays(14)
          $thumb = $cert.Thumbprint
          $scripts = Get-ChildItem $root -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            Set-AuthenticodeSignature -FilePath $s.FullName -Certificate $cert -HashAlgorithm SHA256 | Out-Null
          }
          $signtool = (Get-Command signtool.exe).Source
          $tsa = '${{ env.TSA_URL }}'
          $pe = Get-ChildItem $root -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) {
            & $signtool sign /fd SHA256 /sm /sha1 $thumb /tr $tsa /td SHA256 $f.FullName
          }

      - name: Verify PR script signatures (presence check)
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          $root = (Test-Path '${{ env.SIGN_ROOT }}') ? '${{ env.SIGN_ROOT }}' : '.'
          $unsigned = Get-ChildItem $root -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue | Where-Object { (Get-AuthenticodeSignature $_).Status -eq 'NotSigned' }
          if ($unsigned.Count -gt 0) {
            'Unsigned scripts detected:' | Write-Host
            $unsigned | Select-Object -ExpandProperty FullName | Write-Host
            throw 'Some scripts were not signed in the PR job.'
          } else {
            'All scripts have a signature (trust may be untrusted, which is expected on PRs).' | Write-Host
          }

      - name: Cleanup ephemeral PR cert
        if: ${{ always() && github.event_name == 'pull_request' }}
        run: |
          Get-ChildItem Cert:\CurrentUser\My | Where-Object { $_.Subject -eq 'CN=CI Ephemeral Code Signing' } | ForEach-Object { certutil -user -delstore My $_.Thumbprint | Out-Null }

      - name: Upload unsigned artifacts for trusted runs
        if: ${{ github.event_name == 'push' }}
        uses: actions/upload-artifact@v4
        with:
          name: unsigned
          path: |
            ${{ env.SIGN_ROOT }}/**/*.exe
            ${{ env.SIGN_ROOT }}/**/*.dll
            ${{ env.SIGN_ROOT }}/**/*.msi
            ${{ env.SIGN_ROOT }}/**/*.ps1
            ${{ env.SIGN_ROOT }}/**/*.psm1
          if-no-files-found: error

  codesign-dev:
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/heads/develop') }}
    needs: build
    runs-on: windows-latest
    timeout-minutes: 30
    environment: codesign-dev
    env:
      EXPECTED_THUMBPRINT: ${{ vars.PROD_CERT_THUMBPRINT }}
    steps:
      - name: Download unsigned artifacts
        uses: actions/download-artifact@v4
        with:
          name: unsigned
          path: unsigned

      - name: Require code-signing secrets
        run: |
          if ([string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_B64 }}') -or [string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}')) {
            throw 'Missing WIN_CODESIGN_PFX_B64 or WIN_CODESIGN_PFX_PASSWORD in environment codesign-dev.'
          }

      - name: Decode PFX (temp file)
        run: |
          [IO.File]::WriteAllBytes("$env:RUNNER_TEMP\\codesign.pfx", [Convert]::FromBase64String('${{ secrets.WIN_CODESIGN_PFX_B64 }}'))

      - name: Sign binaries (signtool)
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE signing.'; return }
          $signtool = $signtoolCmd.Source
          $tsa = '${{ env.TSA_URL }}'
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) {
            & $signtool sign /fd SHA256 /f "$env:RUNNER_TEMP\\codesign.pfx" /p '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' /tr $tsa /td SHA256 $f.FullName
          }

      - name: Sign scripts (Authenticode)
        run: |
          if ($env:GITHUB_REPOSITORY -ne 'LabVIEW-Community-CI-CD/icon-editor-lab') {
            Write-Host "Repo is $env:GITHUB_REPOSITORY (fork). Using ephemeral dev cert for script signing."
            $cert = New-SelfSignedCertificate -Subject 'CN=CI Ephemeral Code Signing' -Type CodeSigningCert -CertStoreLocation Cert:\CurrentUser\My -NotAfter (Get-Date).AddDays(14)
          }
          else {
            try {
              $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::UserKeySet `
                     -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable `
                     -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet
              $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                "$env:RUNNER_TEMP\codesign.pfx",
                '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}',
                $flags)
            } catch {
              Write-Warning "Direct PFX load failed; attempting store import fallback. Error: $($_.Exception.Message)"
              $pwd = ConvertTo-SecureString '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' -AsPlainText -Force
              $cert = Import-PfxCertificate -FilePath "$env:RUNNER_TEMP\codesign.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password $pwd
            }
          }
          $tsa = '${{ env.TSA_URL }}'
          $scripts = Get-ChildItem unsigned -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            Set-AuthenticodeSignature -FilePath $s.FullName -Certificate $cert -TimestampServer $tsa -HashAlgorithm SHA256 | Out-Null
          }

      - name: Verify PE signatures
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE verify.'; return }
          $signtool = $signtoolCmd.Source
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) { & $signtool verify /pa $f.FullName }

      - name: Verify script signatures
        run: |
          $expected = '${{ env.EXPECTED_THUMBPRINT }}'
          $invalid = @()
          $scripts = Get-ChildItem unsigned -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            $sig = Get-AuthenticodeSignature $s.FullName
            if ($sig.Status -ne 'Valid') { $invalid += $s.FullName; continue }
            if ($expected -and $sig.SignerCertificate.Thumbprint -ne $expected) {
              throw "Unexpected signer for $($s.Name): $($sig.SignerCertificate.Thumbprint), expected $expected"
            }
          }
          if ($invalid.Count -gt 0) {
            'Scripts with invalid signatures:' | Write-Host
            $invalid | ForEach-Object { $_ | Write-Host }
            throw 'Invalid script signatures'
          }

      - name: Upload signed artifacts (develop)
        uses: actions/upload-artifact@v4
        with:
          name: signed-develop
          path: unsigned

      - name: Cleanup PFX
        if: always()
        run: Remove-Item "$env:RUNNER_TEMP\\codesign.pfx" -Force -ErrorAction SilentlyContinue

  codesign-prod:
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    needs: build
    runs-on: windows-latest
    timeout-minutes: 30
    environment: codesign-prod
    env:
      EXPECTED_THUMBPRINT: ${{ vars.PROD_CERT_THUMBPRINT }}
    steps:
      - name: Download unsigned artifacts
        uses: actions/download-artifact@v4
        with:
          name: unsigned
          path: unsigned

      - name: Require code-signing secrets
        run: |
          if ([string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_B64 }}') -or [string]::IsNullOrWhiteSpace('${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}')) {
            throw 'Missing WIN_CODESIGN_PFX_B64 or WIN_CODESIGN_PFX_PASSWORD in environment codesign-prod.'
          }

      - name: Decode PFX (temp file)
        run: |
          [IO.File]::WriteAllBytes("$env:RUNNER_TEMP\\codesign.pfx", [Convert]::FromBase64String('${{ secrets.WIN_CODESIGN_PFX_B64 }}'))

      - name: Sign binaries (signtool)
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE signing.'; return }
          $signtool = $signtoolCmd.Source
          $tsa = '${{ env.TSA_URL }}'
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) {
            & $signtool sign /fd SHA256 /f "$env:RUNNER_TEMP\\codesign.pfx" /p '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' /tr $tsa /td SHA256 $f.FullName
          }

      - name: Sign scripts (Authenticode)
        run: |
          if ($env:GITHUB_REPOSITORY -ne 'LabVIEW-Community-CI-CD/icon-editor-lab') {
            Write-Host "Repo is $env:GITHUB_REPOSITORY (fork). Using ephemeral dev cert for script signing."
            $cert = New-SelfSignedCertificate -Subject 'CN=CI Ephemeral Code Signing' -Type CodeSigningCert -CertStoreLocation Cert:\CurrentUser\My -NotAfter (Get-Date).AddDays(14)
          }
          else {
            try {
              $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::UserKeySet `
                     -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable `
                     -bor [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet
              $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                "$env:RUNNER_TEMP\codesign.pfx",
                '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}',
                $flags)
            } catch {
              Write-Warning "Direct PFX load failed; attempting store import fallback. Error: $($_.Exception.Message)"
              $pwd = ConvertTo-SecureString '${{ secrets.WIN_CODESIGN_PFX_PASSWORD }}' -AsPlainText -Force
              $cert = Import-PfxCertificate -FilePath "$env:RUNNER_TEMP\codesign.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password $pwd
            }
          }
          $tsa = '${{ env.TSA_URL }}'
          $scripts = Get-ChildItem unsigned -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            Set-AuthenticodeSignature -FilePath $s.FullName -Certificate $cert -TimestampServer $tsa -HashAlgorithm SHA256 | Out-Null
          }

      - name: Verify PE signatures
        run: |
          $signtoolCmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if (-not $signtoolCmd) { Write-Host 'signtool.exe not found; skipping PE verify.'; return }
          $signtool = $signtoolCmd.Source
          $pe = Get-ChildItem unsigned -Include *.exe,*.dll,*.msi -Recurse -ErrorAction SilentlyContinue
          foreach ($f in $pe) { & $signtool verify /pa $f.FullName }

      - name: Verify script signatures
        run: |
          $expected = '${{ env.EXPECTED_THUMBPRINT }}'
          $invalid = @()
          $scripts = Get-ChildItem unsigned -Include *.ps1,*.psm1 -Recurse -ErrorAction SilentlyContinue
          foreach ($s in $scripts) {
            $sig = Get-AuthenticodeSignature $s.FullName
            if ($sig.Status -ne 'Valid') { $invalid += $s.FullName; continue }
            if ($expected -and $sig.SignerCertificate.Thumbprint -ne $expected) {
              throw "Unexpected signer for $($s.Name): $($sig.SignerCertificate.Thumbprint), expected $expected"
            }
          }
          if ($invalid.Count -gt 0) {
            'Scripts with invalid signatures:' | Write-Host
            $invalid | ForEach-Object { $_ | Write-Host }
            throw 'Invalid script signatures'
          }

      - name: Upload signed artifacts (prod)
        uses: actions/upload-artifact@v4
        with:
          name: signed-prod
          path: unsigned

      - name: Cleanup PFX
        if: always()
        run: Remove-Item "$env:RUNNER_TEMP\\codesign.pfx" -Force -ErrorAction SilentlyContinue
